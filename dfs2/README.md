## 刷人利器——深度优先搜索

### 摘要

* 排列组合类搜索
    * 两种组合类DFS的实现方法
    * 使用组合类DFS算法解决K数之和问题
    * DFS的框架模板
* 矩阵上的DFS
* 如何解决求所有最短路线的问题

### 图的BFS

![graphbfs](https://raw.githubusercontent.com/luxcgo/imgs4md/master/img20220604214803.jpeg)

### DFS深度优先搜索回顾

```
从一点开始，任选一条路走到下一个点，直到走到尽头
如果走到尽头，回撤一步，换条路继续走
在遍历的过程中搜索目标值或者目标路径
在同一条路径中不走重复点，在不同路径中走过的点可能可以重复走
```

### BFS vs DFS复杂度

时间复杂度均为：O(V+E)，V为顶点个数，E为边个数 

* 宽度优先搜索的空间复杂度取决于宽度
* 深度优先搜索的空间复杂度取决于深度

### 递归定义

一般来说，如果面试官不特别要求的话，DFS都可以使用递归(Recursion)的方式来实现。<br/>
先递进，再回归——这就是「递归」 简单来说递归就是方法**自己调用自己**，每次调用时**传入不同的变量**。一直到程序**执行到指定的出口时停止调用**本身，并将结果层 层返回。

Recursion(递归)和iteration(迭代)都是**代码的实现方式**，并**不是一种算法**

递归三要素是实现递归的重要步骤：

* 递归的定义
* 递归的拆解
* 递归的出口

### 什么时候使用 DFS?

在之前的课程中，我们知道了二叉树(Binary Tree)的问题大部分都可以用 DFS 求解。除了二叉树以外的 90% DFS 的题，要么是组合(combination)，要么是排列(permutation)。

碰到让你找所有方案的题，基本可以确定是 DFS<br/>
如果题目给了你一个树或者图，可以在上面进行 DFS

**如果题目没有直接给你一个树或图，可以把题目的解空间看成一个树或图，然后在上面进行DFS。找到树或图中的所有满足条件的路径。**<br/>
**路径 = 方案 = 图中节点的排列组合**
